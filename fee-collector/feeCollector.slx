fn check_pair(token_a: Hash, token_b: Hash, dex_hash: Hash) -> bool {
    let dexStorage: ReadOnlyStorage = ReadOnlyStorage::new(dex_hash).expect("noDexStorage");
    let a_u256: u256 = token_a.to_u256();
    let b_u256: u256 = token_b.to_u256();
    
    let (first, second) = a_u256 > b_u256 ? (token_a, token_b) : (token_b, token_a)
    
    let pair_key: string = "pairs_" + first.to_hex();
    let pair_map: optional<map<Hash, Hash>> = dexStorage.load(pair_key);
    return pair_map.is_some() ? true : false;
}

fn swap(token_in_hash: Hash, token_out_hash: Hash, amount_out_min: u64, amount_in: u64, dex_hash: Hash) -> u64 {
    let dex_contract: Contract = Contract::new(dex_hash).unwrap();
    let amount_out: u64 = dex_contract.call(21, [(token_in_hash, token_out_hash, amount_out_min)], { token_in_hash: amount_in });
    return amount_out
} 

entry stake_tokens() {
    let storage: Storage = Storage::new();
    let dao_hash: Hash = storage.load("dao_token").expect("missingDaoToken");
    let deposit_amount: u64 = get_deposit_for_asset(dao_hash).expect("missingDaoDeposit");

    let staker: Address = get_caller().expect("noCaller");
    let stake_ledger: map<Address, u64> = storage.load("stake_ledger").expect("missingStakeLedger");

    let current_stake: u64 = stake_ledger.get(staker).unwrap_or(0);
    let updated_stake: u64 = current_stake + deposit_amount;
    stake_ledger.insert(staker, updated_stake);

    storage.store("stake_ledger", stake_ledger);

    let total_staked: u64 = storage.load("total_staked").unwrap_or(0);
    storage.store("total_staked", total_staked + deposit_amount);
    return 0;
}

entry unstake_tokens(amount: u64) {
    require(amount > 0, "unstakeZero");
    let storage: Storage = Storage::new();
    let dao_hash: Hash = storage.load("dao_token").expect("missingDaoToken");
    let staker: Address = get_caller().expect("noCaller");

    let stake_ledger: map<Address, u64> = storage.load("stake_ledger").expect("missingStakeLedger");
    let staked_amount: u64 = stake_ledger.get(staker).unwrap_or(0);
    require(staked_amount >= amount, "unstakeTooHigh");
    
    let total_staked: u64 = storage.load("total_staked").expect("missingTotalStaked");
    storage.store("total_staked", total_staked - amount);
    
    if staked_amount == amount {
        stake_ledger.swap_remove(staker);
    } else {
        stake_ledger.insert(staker, staked_amount - amount);
    }

    storage.store("stake_ledger", stake_ledger);

    transfer(staker, amount, dao_hash);
    return 0;
}

pub fn distribute_fee(asset_hash: Hash) {
    let storage: Storage = Storage::new();

    let fee_deposit: u64 = get_deposit_for_asset(asset_hash).expect("missingFeeDeposit");
    let total_staked: u64 = storage.load("total_staked").expect("missingTotalStaked");

    require(total_staked > 0, "noStakers");

    let stake_ledger: map<Address, u64> = storage.load("stake_ledger").expect("missingStakeLedger");

    let xel_hash: Hash = storage.load("xel_token").expect("missingXELToken");

    let distribute_asset: Hash = asset_hash;
    let distribute_amount: u64 = fee_deposit;

    // If XEL pair exists, swap fees to XEL
    let dex_hash: Hash = storage.load("dex_hash").expect("missingDexHash");
    if asset_hash != xel_hash && check_pair(asset_hash, xel_hash, dex_hash) {
        let amount_out_min: u64 = 0;
        let swapped: u64 = swap(asset_hash, xel_hash, amount_out_min, distribute_amount, dex_hash);
        distribute_asset = xel_hash;
        distribute_amount = swapped;
    }

    foreach (address, staked_amount) in stake_ledger.entries() {
        if staked_amount == 0 { continue; }

        let share: u64 =
            ((distribute_amount as u128 * staked_amount as u128)
            / total_staked as u128) as u64;

        if share > 0 {
            transfer(address, share, distribute_asset);
        }
    }
}

entry recover_asset(asset_hash: Hash) {
    let storage: Storage = Storage::new();
    let dao_hash: Hash = storage.load("dao_token").expect("missingDaoToken");
    require(asset_hash != dao_hash, "assetCannotBeDAO");

    let caller: Address = get_caller().expect("noCaller");
    let owner: Address = storage.load("contract_owner").expect("missingContractOwner");
    require(caller == owner, "notContractOwner");

    let balance: u64 = get_balance_for_asset(asset_hash).expect("noBalance");
    require(balance > 0, "noBalance");
    transfer(caller, balance, asset_hash);
    return 0;
}

entry update_dex_hash(new_dex_hash: Hash) {
    let storage: Storage = Storage::new();

    let caller: Address = get_caller().expect("noCaller");
    let owner: Address = storage.load("contract_owner").expect("missingContractOwner");
    require(caller == owner, "notContractOwner");

    storage.store("dex_hash", new_dex_hash);
    return 0;
}

hook constructor() -> u64 {
    let storage: Storage = Storage::new();
    let deployer: Address = get_caller().expect("noCaller");

    let dao_asset: optional<Asset> = Asset::create(
        1, 
        "FORGE DAO", 
        "FORGE", 
        8, 
        MaxSupplyMode::Fixed{max_supply: 100_000_000 * 10 ** 8}
    );

    let created_dao: Asset = dao_asset.expect("daoAssetCreationFailed");

    let dao_hash: Hash = created_dao.get_hash();
    transfer(deployer, created_dao.get_supply(), dao_hash);
    
    let empty_stake_ledger: map<Address, u64> = {};
    
    storage.store("dao_token", dao_hash);
    storage.store("stake_ledger", empty_stake_ledger);
    storage.store("total_staked", 0);
    storage.store("contract_owner", deployer);
    let dex_hash: Hash = Hash::from_hex("c9d93c6b59f075156ce002470e34207089e3dfa76832460115c5be8f244ebfd5");

    return 0;
}