entry stake_tokens() {
    let storage: Storage = Storage::new();
    let dao_hash: Hash = storage.load("dao_token").expect("missingDaoToken");
    let deposit_amount: u64 = get_deposit_for_asset(dao_hash).expect("missingDaoDeposit");

    let staker: Address = get_caller().expect("noCaller");
    let stake_ledger: map<Address, u64> = storage.load("stake_ledger").expect("missingStakeLedger");

    let current_stake: u64 = stake_ledger.get(staker).unwrap_or(0);
    let updated_stake: u64 = current_stake + deposit_amount;
    stake_ledger.insert(staker, updated_stake);

    storage.store("stake_ledger", stake_ledger);

    let total_staked: u64 = storage.load("total_staked").unwrap_or(0);
    storage.store("total_staked", total_staked + deposit_amount);
    return 0;
}

entry unstake_tokens(amount: u64) {
    let storage: Storage = Storage::new();
    let dao_hash: Hash = storage.load("dao_token").expect("missingDaoToken");
    let staker: Address = get_caller().expect("noCaller");

    let stake_ledger: map<Address, u64> = storage.load("stake_ledger").expect("missingStakeLedger");
    let staked_amount: u64 = stake_ledger.get(staker).unwrap_or(0);
    require(staked_amount >= amount, "unstakeTooHigh");
    
    let total_staked: u64 = storage.load("total_staked").expect("missingTotalStaked");
    storage.store("total_staked", total_staked - amount);
    
    if staked_amount == amount {
        stake_ledger.swap_remove(staker);
    } else {
        stake_ledger.insert(staker, staked_amount - amount);
    }

    storage.store("stake_ledger", stake_ledger);

    transfer(staker, amount, dao_hash);
    return 0;
}

pub fn distribute_fee(asset_hash: Hash) {
    let storage: Storage = Storage::new();
    let fee_deposit: u64 = get_deposit_for_asset(asset_hash).expect("missingFeeDeposit");
    let total_staked: u64 = storage.load("total_staked").expect("missingTotalStaked");
    require(total_staked > 0, "noStakers");

    let stake_ledger: map<Address, u64> = storage.load("stake_ledger").expect("missingStakeLedger");

    foreach (address, staked_amount) in stake_ledger.entries() {
        if staked_amount == 0 { continue; }
        let share: u64 = ((fee_deposit as u128 * staked_amount as u128) / total_staked as u128) as u64;
        if share > 0 {
            transfer(address, share, asset_hash);
        }
    }
}

entry recover_asset(asset_hash: Hash) {
    let storage: Storage = Storage::new();
    let dao_hash: Hash = storage.load("dao_token").expect("missingDaoToken");
    require(asset_hash != dao_hash, "assetCannotBeDAO");

    let caller: Address = get_caller().expect("noCaller");
    let owner: Address = storage.load("contract_owner").expect("missingContractOwner");
    require(caller == owner, "notContractOwner");

    transfer(caller, get_balance_for_asset(asset_hash), asset_hash);
    return 0;
}

hook constructor() -> u64 {
    let storage: Storage = Storage::new();
    let deployer: Address = get_caller().expect("noCaller");

    let dao_asset: optional<Asset> = Asset::create(
        1, 
        "FORGE DAO", 
        "FORGE", 
        8, 
        MaxSupplyMode::Fixed{max_supply: 100_000_000 * 10 ** 8}
    );

    let created_dao: Asset = dao_asset.expect("daoAssetCreationFailed");

    let dao_hash: Hash = created_dao.get_hash();
    transfer(deployer, created_dao.get_supply(), dao_hash);
    
    let empty_stake_ledger: map<Address, u64> = {};
    
    storage.store("dao_token", dao_hash);
    storage.store("stake_ledger", empty_stake_ledger);
    storage.store("total_staked", 0);
    storage.store("contract_owner", deployer);

    return 0;
}
