struct CAsset {
    assetId: u64,
    owner: optional<Address>,
    icon: string
}

struct Balance {
    balance: u64,
    asset: Hash,
    source: Address
}

fn (balance Balance) charge(cost: u64, payable: bool) {
    require(cost <= balance.balance, "balanceTooLow");

    if (payable) {
        let dao_hash: Hash = Storage::new().load("DAOHash").expect("missingDAOHash");
        let dao_contract: Module = Module::new(dao_hash).unwrap();
        dao_contract.execute(2, [balance.asset], { balance.asset: cost });
    }

    balance.balance -= cost;
}

fn (balance Balance) refund() {
    if (balance.balance > 0) {
        transfer(balance.source, balance.balance, balance.asset);
    }
}

fn mintAndTransfer(asset: Asset, amount: u64, owner: Address, asset_hash: Hash) {
    asset.mint(amount);
    transfer(owner, amount, asset_hash);
}

fn newAssetId() -> u64 {
    let storage: Storage = Storage::new();
    let assetId: u64 = storage.load("lastAssetId").expect("missingLastAssetId");
    assetId = assetId + 1;
    storage.store("lastAssetId", assetId);
    return assetId;
}

entry deployAsset(name: string, ticker: string, decimals: u8, supply: u64, maxSupplyMode: MaxSupplyMode, icon: string) {
    let storage: Storage = Storage::new();
    let owner: Address = Transaction::current().expect("noTransaction").source();
    let fee: u64 = storage.load("fee").expect("missingFee");
    let xelis: Hash = Hash::zero();

    let xel_balance: Balance = Balance { 
        balance: get_deposit_for_asset(xelis).expect("missingXelDeposit"), 
        asset: xelis,
        source: owner
    };
    
    xel_balance.charge(fee, true);
    
    let assetId: u64 = newAssetId();
    let finalMaxSupply: u64 = 0;
    let asset: optional<Asset>;

    xel_balance.charge(100000000, false); // Deduct protocol asset fee from tracked refund
    
    asset = Asset::create(assetId, name, ticker, decimals, maxSupplyMode);
    
    require(asset.is_some(), "assetNotCreated");
    let createdAsset: Asset = asset.expect("assetCreationFailed");
    let assetHash: Hash = createdAsset.get_hash()
     
    match maxSupplyMode {
        MaxSupplyMode::Fixed { max_supply }  => {transfer(owner, max_supply, assetHash);}
        MaxSupplyMode::Mintable { max_supply } => {
            require(supply <= max_supply, "mintOverMax");
            mint_and_transfer(createdAsset, supply, owner, assetHash);
        }
        MaxSupplyMode::None => {mint_and_transfer(createdAsset, supply, owner, assetHash);}
    }
    
    let casset: CAsset = CAsset { 
        assetId: assetId, 
        owner: owner,
        icon: icon
    };
    
    let source: Address = Transaction::current().expect("noTransaction").source();
    
    storage.store(assetHash, casset);
    fire_event(1, assetHash);
    xel_balance.refund();
    return 0;
}

entry mint(assetHash: Hash, amount: u64) {
    let casset: CAsset = Storage::new().load(assetHash).expect("assetNotFound");
    let source: Address = Transaction::current().expect("noTransaction").source();
    
    require(source == casset.owner.expect("assetOwnerNotSet"), "notAssetOwner");
    let asset: Asset = Asset::get_by_id(casset.assetId).expect("assetNotFoundById");
    require(asset.is_mintable(), "assetNotMintable");
    

    require((asset.get_supply() + amount) <= asset.get_max_supply().unwrap_or(u64::MAX), "mintOverMax");
    
    asset.mint(amount);
    transfer(source, amount, asset.get_hash());
    return 0;
}

entry transferOwnership(assetHash: Hash, newOwner: Address) {
    let storage: Storage = Storage::new();
    let casset: CAsset = storage.load(assetHash).expect("assetNotFound");
    require(Transaction::current().expect("noTransaction").source() == casset.owner.expect("noAssetOwner"), "notAssetOwner");
    
    casset.owner = newOwner;
    storage.store(assetHash, casset);
    return 0;
}

entry renounceOwnership(assetHash: Hash) {
    let storage: Storage = Storage::new();
    let casset: CAsset = storage.load(assetHash).expect("assetNotFound");
    require(Transaction::current().expect("noTransaction").source() == casset.owner.expect("noAssetOwner"), "notAssetOwner");
    
    casset.owner = null;
    storage.store(assetHash, casset);
    return 0;
}

entry setIcon(assetHash: Hash, newIcon: string) {
    let storage: Storage = Storage::new();
    let casset: CAsset = storage.load(assetHash).expect("assetNotFound");
    require(Transaction::current().expect("noTransaction").source() == casset.owner.expect("noAssetOwner"), "notAssetOwner");
    
    casset.icon = newIcon;
    storage.store(assetHash, casset);
    return 0;
}

entry setFee(newFee: u64) {
    let storage: Storage = Storage::new();
    let owner: Address = storage.load("owner").expect("missingContractOwner");
    require(Transaction::current().expect("noTransaction").source() == owner, "notContractOwner");
    storage.store("fee", newFee);
    return 0;
}

hook constructor() -> u64 {
    let storage: Storage = Storage::new();
    storage.store("lastAssetId", 0);
    storage.store("owner", Transaction::current().expect("noTransaction").source());
    storage.store("DAOHash", Hash::from_hex("11eeb595cfc3e7079dce73448e00352c84e84172b5bf1f266ca45e9dd10f6ce5"));
    storage.store("fee", 1 * 10 ** 8);
    return 0;
}
