const MINIMUM_LIQUIDITY: u64 = 1000;

struct LPAsset {
    asset_id: u64,
    reserves: map<Hash, u64>
}

fn min(x: u64, y: u64) -> u64 {
    if x < y {
        return x;
    } else { 
        return y; 
    }
}

fn xor_bytes(a: bytes, b: bytes) -> bytes {
    let result: bytes = bytes::new();
    require(a.len() == b.len(), "bytesNotEqualLength");

    for i: u32 = 0; i < a.len(); i += 1 {
        result.push(a[i] ^ b[i]);
    }

    return result; 
}

fn xor_hash(a: Hash, b: Hash) -> Hash {
    return Hash::from_bytes(xor_bytes(a.to_bytes(), b.to_bytes()));
}

fn new_asset_id() -> u64 {
    let storage: Storage = Storage::new();
    let asset_id: u64 = storage.load("lastAssetId").expect("missingLastAssetId");
    asset_id = asset_id + 1;
    storage.store("lastAssetId", asset_id);
    return asset_id;
}

fn get_pair_asset(token_a_hash: Hash, token_b_hash: Hash) -> optional<Hash> {
    let storage: Storage = Storage::new();
    let lp_hash: optional<Hash> = storage.load(xor_hash(token_a_hash, token_b_hash));
    return lp_hash;
}

fn create_pair(token_a_hash: Hash, token_b_hash: Hash) -> Hash {
    let storage: Storage = Storage::new();
    let asset_id: u64 = new_asset_id();
    let ticker_a: string = Asset::get_by_hash(token_a_hash).expect("tokenANotFound").get_ticker();
    let ticker_b: string = Asset::get_by_hash(token_b_hash).expect("tokenBNotFound").get_ticker();
    let name: string = ticker_a + " " + ticker_b + " LP"; 
    let ticker: string = "LP";
    let decimals: u8 = 8; 
    let asset: optional<Asset> = Asset::create(asset_id, name, ticker, decimals, MaxSupplyMode::None);
    require(asset.is_some(), "assetNotCreated");
    let asset: Asset = asset.expect("assetCreationFailed");
    
    let lp_asset: LPAsset = LPAsset { 
        asset_id: asset_id, 
        reserves: {token_a_hash: 0, token_b_hash: 0}
    };
    let lp_asset_hash: Hash = asset.get_hash();
    storage.store(lp_asset_hash, lp_asset);
    storage.store(xor_hash(token_a_hash, token_b_hash), lp_asset_hash);
    return lp_asset_hash;
}

fn quote(amount_a: u64, reserve_a: u64, reserve_b: u64) -> u64 {
    require(amount_a > 0, "insufficientAmount");
    require(reserve_a > 0 && reserve_b > 0, "insufficientLiquidity");
    let amount_b: u64 = amount_a * reserve_b / reserve_a;
    return amount_b;
}

fn calculate_optimal_liquidity(amount_a_in: u64, amount_b_in: u64, reserve_a: u64, reserve_b: u64, token_a: Hash, token_b: Hash) -> (u64, u64) {
    let amount_b_optimal: u64 = quote(amount_a_in, reserve_a, reserve_b);
    if amount_b_optimal <= amount_b_in {
        if amount_b_optimal < amount_b_in {
            transfer(get_caller().expect("noCaller"), amount_b_in - amount_b_optimal, token_b);
        }
        return (amount_a_in, amount_b_optimal);
    } else {
        let amount_a_optimal: u64 = quote(amount_b_in, reserve_b, reserve_a);
        assert(amount_a_optimal <= amount_a_in);
        if amount_a_optimal < amount_a_in {
            transfer(get_caller().expect("noCaller"), amount_a_in - amount_a_optimal, token_a);
        }
        return (amount_a_optimal, amount_b_in);
    }
}

fn get_liquidity_amounts(liquidity_token_hash: Hash, xel_balance: optional<u64>) -> (u64, u64) {
    let storage: Storage = Storage::new();
    let lp_asset: LPAsset = storage.load(liquidity_token_hash).expect("lpAssetNotFound");
    let token_hashes: Hash[] = lp_asset.reserves.keys();
    let token_a: Hash = token_hashes[0];
    let token_b: Hash = token_hashes[1];
    let amount_a_in: u64 = 0;
    let amount_b_in: u64 = 0;
    if (xel_balance.is_some()) {
        if (Hash::zero() == token_a) {
            amount_a_in = xel_balance.unwrap();
            amount_b_in = get_deposit_for_asset(token_b).expect("noTokenBDeposit");
        }
        if (Hash::zero() == token_b) {
            amount_a_in = get_deposit_for_asset(token_a).expect("noTokenBDeposit");
            amount_b_in = xel_balance.unwrap();
        }
    }
    else {
        amount_a_in = get_deposit_for_asset(token_a).expect("noTokenADeposit");
        amount_b_in = get_deposit_for_asset(token_b).expect("noTokenBDeposit");
    }

    let reserve_a: u64 = lp_asset.reserves.get(token_a).expect("noReserveA");
    let reserve_b: u64 = lp_asset.reserves.get(token_b).expect("noReserveB");

    if (reserve_a == 0 && reserve_b == 0) {
        return (amount_a_in, amount_b_in);
    } else {
        return calculate_optimal_liquidity(amount_a_in, amount_b_in, reserve_a, reserve_b, token_a, token_b);
    }
}

fn calculate_liquidity(amount_a: u64, amount_b: u64, l_total_supply: u64, l_reserve_a: u64, l_reserve_b: u64, liquidity_token_hash: Hash) -> u64 {
    if l_total_supply == 0 {
        Asset::get_by_hash(liquidity_token_hash).expect("noAsset").mint(MINIMUM_LIQUIDITY);
        let liquidity: u64 = (((amount_a as u128) * (amount_b as u128)).sqrt() as u64) - (MINIMUM_LIQUIDITY);
        return liquidity;
    } else {
        return min(
            (((amount_a as u128) * (l_total_supply as u128) / (l_reserve_a as u128)) as u64), 
            (((amount_b as u128) * (l_total_supply as u128) / (l_reserve_b as u128)) as u64)
        );
    }
}

fn mint_liquidity(amount_a: u64, amount_b: u64, liquidity_token_hash: Hash) {
    let storage: Storage = Storage::new();
    let asset: Asset = Asset::get_by_hash(liquidity_token_hash).expect("noAsset");
    let l_total_supply: u64 = asset.get_supply();
    let lp_asset: LPAsset = storage.load(liquidity_token_hash).expect("noLPAsset");
    let token_hashes: Hash[] = lp_asset.reserves.keys();
    let token_a: Hash = token_hashes[0];
    let token_b: Hash = token_hashes[1];

    let l_reserve_a: u64 = lp_asset.reserves.get(token_a).expect("missingReserveA");
    let l_reserve_b: u64 = lp_asset.reserves.get(token_b).expect("missingReserveB");
    
    let liquidity: u64 = calculate_liquidity(amount_a, amount_b, l_total_supply, l_reserve_a, l_reserve_b, liquidity_token_hash);
    require(liquidity > 0, "insufficientLiquidityMinted");
    
    asset.mint(liquidity);
    transfer(get_caller().expect("noCaller"), liquidity, liquidity_token_hash);

    l_reserve_a = l_reserve_a + amount_a;
    l_reserve_b = l_reserve_b + amount_b;
    lp_asset.reserves = {token_a: l_reserve_a, token_b: l_reserve_b};
    fire_event(1, (Transaction::current().expect("missingTransaction").hash(), lp_asset.reserves));
    storage.store(liquidity_token_hash, lp_asset);
}

fn calculate_swap_output(amount_in: u64, l_reserve_in: u64, l_reserve_out: u64, token_in_hash: Hash) -> u64 {
    let amount_in_with_dev_fee: u128 = (amount_in as u128) * (9997) / (10000);
    let dev_fee: u64 = amount_in - amount_in_with_dev_fee as u64;
    let storage: Storage = Storage::new();

    let dao_hash: Hash = Storage::new().load("DAOHash").expect("missingDAOHash");
    let dao_contract: Module = Module::new(dao_hash).unwrap();
    dao_contract.call(2, [token_in_hash], { token_in_hash: dev_fee });

    let amount_in_with_lp_fee: u128 = amount_in_with_dev_fee * (9978);
    let numerator: u128 = amount_in_with_lp_fee * (l_reserve_out as u128);
    let denominator: u128 = (l_reserve_in as u128) * (10000) + (amount_in_with_lp_fee);

    require(denominator > 0, "divisionByZero");
    return (numerator / denominator) as u64;
}

entry add_liquidity(token0_hash: Hash, token1_hash: Hash) {
    require(token0_hash != token1_hash, "duplicateTokenInput");
    let liquidity_token_optional: optional<Hash> = get_pair_asset(token0_hash, token1_hash);
    let liquidity_token_hash: Hash = Hash::zero();
    let xel_balance: optional<u64> = null;
    if liquidity_token_optional.is_none() {
        let xelis: Hash = Hash::zero();
        xel_balance = get_deposit_for_asset(xelis).expect("missingXelDeposit").checked_sub(100000000).expect("insufficientXelForPairCreation");
        liquidity_token_hash = create_pair(token0_hash, token1_hash);
    } else {
        liquidity_token_hash = liquidity_token_optional.expect("pairNotFound");
    }
    let (amount_a, amount_b): (u64, u64) = get_liquidity_amounts(liquidity_token_hash, xel_balance);
    mint_liquidity(amount_a, amount_b, liquidity_token_hash);
    return 0;
}

entry remove_liquidity(liquidity_token_hash: Hash) {
    let storage: Storage = Storage::new();
    let liquidity: u64 = get_deposit_for_asset(liquidity_token_hash).expect("noDeposit");
    let l_total_supply: u64 = Asset::get_by_hash(liquidity_token_hash).expect("noAsset").get_supply();

    let lp_asset: LPAsset = storage.load(liquidity_token_hash).expect("noLPAsset");
    let token_hashes: Hash[] = lp_asset.reserves.keys();
    let token_a: Hash = token_hashes[0];
    let token_b: Hash = token_hashes[1];

    let l_reserve_a: u64 = lp_asset.reserves.get(token_a).expect("noReserveA");
    let l_reserve_b: u64 = lp_asset.reserves.get(token_b).expect("noReserveB");

    let amount_a: u64 = ((liquidity as u128) * (l_reserve_a  as u128) / l_total_supply as u128) as u64;
    let amount_b: u64 = ((liquidity as u128) * (l_reserve_b as u128) / l_total_supply as u128) as u64;

    require(amount_a > 0 && amount_b > 0, "insufficientLiquidityBurned");
    
    burn(liquidity, liquidity_token_hash);

    l_reserve_a = l_reserve_a - amount_a;
    l_reserve_b = l_reserve_b - amount_b;
    lp_asset.reserves = {token_a: l_reserve_a, token_b: l_reserve_b};
    storage.store(liquidity_token_hash, lp_asset);

    let source: Address = get_caller().expect("noCaller");
    transfer(source, amount_a, token_a);
    transfer(source, amount_b, token_b);
    fire_event(1, (Transaction::current().expect("missingTransaction").hash(), lp_asset.reserves));
    return 0;
}

entry swap(token_in_hash: Hash, token_out_hash: Hash, amount_out_min: u64) {
    let amount_in: u64 = get_deposit_for_asset(token_in_hash).expect("noDeposit");
    require(amount_in > 0, "noDeposit");
    
    let storage: Storage = Storage::new();
    let lp_asset_hash: Hash = get_pair_asset(token_in_hash, token_out_hash).expect("noPairFound");
    let lp_asset: LPAsset = storage.load(lp_asset_hash).expect("noLPAsset");
    let l_reserve_in: u64 = lp_asset.reserves.get(token_in_hash).expect("noReserveIn");
    let l_reserve_out: u64 = lp_asset.reserves.get(token_out_hash).expect("noReserveOut");
    
    let amount_out: u64 = calculate_swap_output(amount_in, l_reserve_in, l_reserve_out, token_in_hash);

    require(amount_out >= amount_out_min, "slippageExceeded");
    require(amount_out > 0, "insufficientOutputAmount");
    require(amount_out < l_reserve_out, "insufficientLiquidity");

    l_reserve_in = l_reserve_in + amount_in;
    l_reserve_out = l_reserve_out - amount_out;
    lp_asset.reserves = {token_in_hash: l_reserve_in, token_out_hash: l_reserve_out};
    fire_event(1, (Transaction::current().expect("missingTransaction").hash(), lp_asset.reserves));
    storage.store(lp_asset_hash, lp_asset);

    transfer(get_caller().expect("noCaller"), amount_out, token_out_hash);
    return 0;
}

hook constructor() -> u64 {
    let storage: Storage = Storage::new();
    storage.store("lastAssetId", 0);
    let source: Address = get_caller().expect("noCaller");
    storage.store("DAOHash", Hash::from_hex("11eeb595cfc3e7079dce73448e00352c84e84172b5bf1f266ca45e9dd10f6ce5"));
    storage.store("owner", source);
    storage.store("feeAddress", source);
    return 0;
}